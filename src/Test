import sys
import pygame
import os
import random
from pathlib import Path
import json

# ----------------------------
# SETTINGS
# ----------------------------
SCREEN_WIDTH = 1100
SCREEN_HEIGHT = 740
LOWER_MARGIN = 100
SIDE_MARGIN = 300
FPS = 60
ROWS = 16
TILE_SIZE = SCREEN_HEIGHT // ROWS

# Paths
PROJECT_ROOT = Path(__file__).resolve().parent.parent
ASSETS = PROJECT_ROOT / "assets" / "LevelEditor-main" / "LevelEditor-main" / "img"
TILE_ASSETS = ASSETS / "tile"
BG_ASSETS = ASSETS / "Background"
LEVEL_FILE = PROJECT_ROOT / "src" / "level.json"

# Colors
WHITE = (255, 255, 255)
GAME_BG = (30, 30, 30)

# ----------------------------
# INIT
# ----------------------------
pygame.init()
screen = pygame.display.set_mode((SCREEN_WIDTH + SIDE_MARGIN, SCREEN_HEIGHT + LOWER_MARGIN))
pygame.display.set_caption("Run Red, Run!")
clock = pygame.time.Clock()

# ----------------------------
# LOAD BACKGROUND
# ----------------------------
def load_image_safe(path):
    try:
        return pygame.image.load(str(path)).convert_alpha()
    except:
        surf = pygame.Surface((64,64))
        surf.fill((255,0,255))
        return surf

sky_img = load_image_safe(BG_ASSETS / "sky_cloud.png")
mountain_img = load_image_safe(BG_ASSETS / "mountain.png")
pine1_img = load_image_safe(BG_ASSETS / "pine1.png")
pine2_img = load_image_safe(BG_ASSETS / "pine2.png")

# ----------------------------
# LOAD TILES
# ----------------------------
img_list = []
tile_files = sorted(TILE_ASSETS.glob("*.png"))
if not tile_files:
    raise FileNotFoundError(f"No tile images found in {TILE_ASSETS}")
for tile_path in tile_files:
    img_list.append(load_image_safe(tile_path))

# ----------------------------
# LOAD PLAYER / WOLF FRAMES
# ----------------------------
def load_frames(paths, scale=1.0):
    frames = []
    for p in paths:
        img = load_image_safe(p)
        if scale != 1.0:
            img = pygame.transform.scale(img, (int(img.get_width()*scale), int(img.get_height()*scale)))
        frames.append(img)
    return frames

PLAYER_SCALE = 0.8  # adjust smaller here
PLAYER_IDLE_FRAMES = load_frames([ASSETS / f"red_idle_{i}.png" for i in range(1,9)], PLAYER_SCALE)
PLAYER_RUN = load_frames([ASSETS / f"red_run_{i}.png" for i in range(1,24)], PLAYER_SCALE)

WOLF_IDLE = load_frames([ASSETS / "wolf_stand_1.png"], 1.5)[0]
WOLF_RUN = load_frames([ASSETS / f"wolf_run_{i}.png" for i in range(1,10)], 1.5)

# ----------------------------
# WORLD
# ----------------------------
class World:
    def __init__(self):
        self.tile_list = []
        self.obstacle_list = []
        self.kill_list = [] 
        self.vine_list = []

    def process_data(self, data):
        self.tile_list = []
        self.obstacle_list = []

        for entry in data:
            tile_index = entry.get("tile_index", -1)
            grid_x = entry.get("x", 0)
            grid_y = entry.get("y", 0)
            scale = max(0.1, entry.get("scale", 1.0))  # prevent zero/negative scale

            if 0 <= tile_index < len(img_list):
                img = img_list[tile_index]

                # Apply the saved scale
                new_size = (int(TILE_SIZE * scale), int(TILE_SIZE * scale))
                img = pygame.transform.scale(img, new_size)

                px = int(grid_x * TILE_SIZE)
                py = int(grid_y * TILE_SIZE)

                rect = pygame.Rect(px, py, img.get_width(), img.get_height())
                self.tile_list.append((img, rect))

                # Preserve collision info
                if tile_index == 5 or tile_index == 3 or (tile_index>= 129 and tile_index<= 133) or (tile_index >= 58 and tile_index <= 93):
                    self.obstacle_list.append((img, rect))

                #Lethal (top water)
                if tile_index == 14:
                    # Expand water kill zone upward so partial water still kills
                    kill_rect = rect.copy()
                    kill_rect.y -= int(TILE_SIZE * 0.025)  # extend 30% of tile height upward
                    kill_rect.height += int(TILE_SIZE * 0.3)
                    self.kill_list.append((img, kill_rect))


                # climbable vines
                if 120 <= tile_index <= 123:
                     self.vine_list.append((img, rect))


    def draw(self, surf, scroll):
        for img, rect in self.tile_list:
            surf.blit(img, (rect.x - scroll, rect.y))
            # optional: draw red collision boxes for debugging
            #pygame.draw.rect(surf, (255, 0, 0), (rect.x - scroll, rect.y, rect.width, rect.height), 2)


# ----------------------------
# PLAYER / WOLF CLASSES
# ----------------------------
GRAVITY = 0.85
JUMP_POWER = 11
BASELINE_Y = SCREEN_HEIGHT // 2
PLAYER_FOOT_OFFSET = 50
WOLF_FOOT_OFFSET = 0
WOLF_EDGE_X = 8
STARTING_GAP = 220

class Player(pygame.sprite.Sprite):
    def __init__(self, idle_frames, run_frames, x, baseline_y, foot_offset=0, speed=5):
        super().__init__()
        self.idle_frames = idle_frames
        self.run_frames = run_frames
        self.frame_index = 0
        self.image = self.idle_frames[0] if idle_frames else pygame.Surface((64,64))
        self.rect = self.image.get_rect()
        self.baseline_y = baseline_y + foot_offset
        self.x = float(x)
        self.y = float(self.baseline_y)
        self.rect.midbottom = (int(self.x), int(self.y))
        self.flip = False
        self.speed = speed
        self.vel_y = 0.0
        self.airborne = False
        self.frame_time_ms = 1000//12
        self._last_update = pygame.time.get_ticks()

    def try_jump(self):
        if not self.airborne:
            self.vel_y = -JUMP_POWER
            self.airborne = True

    def move_and_animate(self, dx, obstacles):
        # ----------------
        # HORIZONTAL MOVE
        # ----------------
        self.x += dx
        self.rect.midbottom = (int(self.x), int(self.y))
        for _, rect in obstacles:
            if self.rect.colliderect(rect):
                if dx > 0:  # moving right
                    # Step-up test: is there room to step onto this block?
                    step_height = rect.top - self.rect.bottom
                    if 0 < step_height <= TILE_SIZE * 0.3:  # small ledge
                        self.rect.bottom = rect.top
                        self.vel_y = 0
                        self.airborne = False
                    else:
                        self.rect.right = rect.left
                elif dx < 0:  # moving left
                    step_height = rect.top - self.rect.bottom
                    if 0 < step_height <= TILE_SIZE * 0.3:
                        self.rect.bottom = rect.top
                        self.vel_y = 0
                        self.airborne = False
                    else:
                        self.rect.left = rect.right
                # Sync float position
                self.x = self.rect.midbottom[0]



        # ----------------
        # VERTICAL MOVE
        # ----------------
        self.vel_y += GRAVITY
        self.y += self.vel_y
        self.rect.midbottom = (int(self.x), int(self.y))
        for _, rect in obstacles:
            if self.rect.colliderect(rect):
                if self.vel_y > 0:  # falling
                    self.rect.bottom = rect.top
                    self.vel_y = 0
                    self.airborne = False
                elif self.vel_y < 0:  # jumping
                    self.rect.top = rect.bottom
                    self.vel_y = 0
                self.y = self.rect.midbottom[1]


        # ----------------
        # ANIMATION
        # ----------------
        seq = self.run_frames if dx != 0 or self.airborne else self.idle_frames

        # Reset frame index if sequence changed
        if seq != getattr(self, "_current_seq", None):
            self.frame_index = 0
            self._current_seq = seq

        # Use the current sequence
        if self._current_seq:
            now = pygame.time.get_ticks()
            if now - self._last_update > self.frame_time_ms:
                self._last_update = now
                self.frame_index = (self.frame_index + 1) % len(self._current_seq)
            self.image = self._current_seq[self.frame_index]

        # --- Keep the same rect position after changing image ---
        old_midbottom = self.rect.midbottom  # preserve corrected collision position
        self.rect = self.image.get_rect()
        self.rect.midbottom = old_midbottom

        # Keep float position in sync
        self.x = float(self.rect.midbottom[0])
        self.y = float(self.rect.midbottom[1])

    def on_vine(self, vines):
        """Check if player is touching any vine tile."""
        for _, r in vines:
            if self.rect.colliderect(r):
                return True
        return False

    def draw(self, surf, scroll):
        # Draw the player with horizontal scroll offset
        surf.blit(pygame.transform.flip(self.image, self.flip, False), (self.rect.x - scroll, self.rect.y))

class WolfStatic(pygame.sprite.Sprite):
    def __init__(self, run_frames, idle_img, x, baseline_y, flip=False):
        super().__init__()
        self.frames = run_frames
        self.idle_img = idle_img
        self.frame_index = 0
        self.image = idle_img
        self.rect = self.image.get_rect()
        self.flip = flip
        self.baseline_y = baseline_y
        self.left_x = x
        self.frame_time_ms = 1000//12
        self._last_update = pygame.time.get_ticks()
        self.running = False
        self.rect.left = x
        self.rect.bottom = baseline_y

    def set_running(self, running):
        self.running = running

    def update(self):
        if self.running and self.frames:
            now = pygame.time.get_ticks()
            if now - self._last_update >= self.frame_time_ms:
                self._last_update = now
                self.frame_index = (self.frame_index + 1) % len(self.frames)
            self.image = self.frames[self.frame_index]
        else:
            self.image = self.idle_img
        left = self.rect.left
        self.rect = self.image.get_rect()
        self.rect.left = left
        self.rect.bottom = self.baseline_y

    def draw(self, surf):
        surf.blit(pygame.transform.flip(self.image, self.flip, False), self.rect)

# ----------------------------
# MAIN LOOP
# ----------------------------
def main():
    scroll = 0
    moving_left = moving_right = False

    # Load level
    if LEVEL_FILE.exists():
        with open(LEVEL_FILE, "r") as f:
            level_data = json.load(f)
    else:
        level_data = []

    world_instance = World()
    world_instance.process_data(level_data)

    player = Player(PLAYER_IDLE_FRAMES, PLAYER_RUN, 100, BASELINE_Y, PLAYER_FOOT_OFFSET)
    wolf = WolfStatic(WOLF_RUN, WOLF_IDLE, WOLF_EDGE_X, BASELINE_Y)

    running = True
    while running:
        clock.tick(FPS)
        screen.fill(GAME_BG)

        dx = 0
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_a: moving_left = True
                if event.key == pygame.K_d: moving_right = True
                if event.key in (pygame.K_w, pygame.K_SPACE): player.try_jump()
            if event.type == pygame.KEYUP:
                if event.key == pygame.K_a: moving_left = False
                if event.key == pygame.K_d: moving_right = False

        dx = (-player.speed if moving_left else player.speed if moving_right else 0)

        # --- Handle camera scroll ---
        screen_center_x = SCREEN_WIDTH // 2
        player_screen_x = player.x - scroll

        if player_screen_x > screen_center_x and dx > 0:
            scroll += dx
        elif player_screen_x < screen_center_x and dx < 0:
            scroll += dx

        scroll = max(0, scroll)

        # --- Draw background ---
        for i in range(16):
            offset_x = i * sky_img.get_width()
            screen.blit(sky_img, (offset_x - scroll * 0.4, 0))
            screen.blit(mountain_img, (offset_x - scroll * 0.6, SCREEN_HEIGHT - mountain_img.get_height() - 260))
            screen.blit(pine1_img, (offset_x - scroll * 0.7, SCREEN_HEIGHT - pine1_img.get_height() - 100))
            screen.blit(pine2_img, (offset_x - scroll * 0.8, SCREEN_HEIGHT - pine2_img.get_height() + 20))

        # --- Draw tiles / obstacles ---
        world_instance.draw(screen, scroll)
        # --- Update player (with collision) ---
        player.move_and_animate(dx, world_instance.obstacle_list)

        # --- Vines: climbing mechanic ---
        on_vine = player.on_vine(world_instance.vine_list)
        keys = pygame.key.get_pressed()

        if on_vine:
            climb_speed = player.speed * 0.6
            slide_speed = 2.0
            moving_vertically = False

            if keys[pygame.K_w]:
                player.y -= climb_speed
                player.vel_y = 0
                player.airborne = False
                moving_vertically = True
            elif keys[pygame.K_s]:
                player.y += climb_speed
                player.vel_y = 0
                player.airborne = False
                moving_vertically = True
                

            # Prevent clipping through platforms while climbing
            player.rect.midbottom = (int(player.x), int(player.y))
            for _, rect in world_instance.obstacle_list:
                if player.rect.colliderect(rect):
                    if keys[pygame.K_w]:  # climbing up into a ceiling
                        player.rect.top = rect.bottom
                        player.y = player.rect.midbottom[1]
                    elif keys[pygame.K_s]:  # climbing down into floor
                        player.rect.bottom = rect.top
                        player.y = player.rect.midbottom[1]

            # If not pressing up/down, she starts to fall normally
            if not moving_vertically:
                player.airborne = True

        else:
            # Not on a vine — normal physics apply
            pass




        # --- Check for deadly block (tile_index 14) collision ---
        for _, rect in world_instance.kill_list:
            if player.rect.colliderect(rect):
                # Reset player to start position
                player.x = 100
                player.y = BASELINE_Y
                player.vel_y = 0
                player.airborne = False
                scroll = 0  # optional: reset camera to beginning
                break  # stop checking once hit

        # --- Draw player ---
        player.draw(screen, scroll)


        # --- Update wolf ---
        wolf.set_running(dx)
        wolf.update()
        wolf.draw(screen)

        pygame.display.flip()

    pygame.quit()
    sys.exit()


if __name__=="__main__":
    main()
